# 智能缓存功能实现文档

## 🎉 功能概述

实现了"智能保留 + 清晰提示"方案，让用户体验更加流畅和清晰。

## ✨ 核心功能

### 1. 智能缓存策略

**保留思维导图的条件：**
- ✅ 页面 URL 没有变化
- ✅ 页面标题没有变化
- ✅ 生成时间在 30 分钟内

**自动清空的条件：**
- 🗑️ 切换到不同页面（URL 变化）
- 🗑️ 页面标题变化（内容可能更新）
- 🗑️ 缓存超过 30 分钟

### 2. 缓存状态提示

当显示缓存的思维导图时，顶部会显示紫色渐变状态栏：

```
┌─────────────────────────────────────────────────────┐
│ 📌 缓存的思维导图  生成于 5分钟前                      │
│                        [🔄 重新生成] [🗑️ 清空]        │
└─────────────────────────────────────────────────────┘
```

**状态栏特点：**
- 📌 图标动画：轻微脉动效果
- ⏰ 时间自动更新：每 30 秒更新一次
- 🎨 美观的渐变背景
- 🔄 平滑的显示动画

### 3. 用户操作

**重新生成按钮：**
- 清空当前缓存
- 重新抓取页面内容
- 生成新的思维导图

**清空按钮：**
- 清空缓存的思维导图
- 返回初始状态
- 显示"生成思维导图"按钮

## 🏗️ 技术实现

### 新增属性

```javascript
// 在构造函数中添加
this.cachedPageUrl = null;           // 缓存的页面URL
this.cachedPageTitle = null;         // 缓存的页面标题
this.mindmapGeneratedTime = null;    // 思维导图生成时间
this.cacheTimeout = 30 * 60 * 1000;  // 缓存超时时间（30分钟）
```

### 核心方法

1. **`_checkAndClearIfPageChanged()`**
   - 在 `show()` 方法开始时调用
   - 检查页面是否变化
   - 自动清空过期或不匹配的缓存

2. **`_clearCachedMindmap()`**
   - 清空思维导图数据
   - 重置缓存信息
   - 隐藏状态栏
   - 禁用导出按钮

3. **`_showCacheStatusBar()`**
   - 显示缓存状态栏
   - 更新时间显示
   - 启动定时更新

4. **`_hideCacheStatusBar()`**
   - 隐藏缓存状态栏

5. **`_updateCacheTimeDisplay()`**
   - 更新"生成于 xx 前"的时间显示

6. **`_formatTimeAgo(milliseconds)`**
   - 格式化时间为友好的文本
   - 支持：秒、分钟、小时、天

7. **`_startCacheTimeUpdater()`**
   - 启动定时器，每 30 秒更新时间显示

8. **`_stopCacheTimeUpdater()`**
   - 停止定时器

9. **`handleRegenerateClick()`**
   - 处理重新生成按钮点击

10. **`handleClearCacheClick()`**
    - 处理清空缓存按钮点击

### 修改的方法

1. **`showMindmap(data)`**
   - 保存缓存信息（URL、标题、时间）
   - 隐藏状态栏（新生成的不显示）

2. **`show()`**
   - 开始时调用 `_checkAndClearIfPageChanged()`
   - 检查并显示缓存状态栏

3. **`saveState()`**
   - 保存缓存信息到 localStorage

4. **`loadSavedState()`**
   - 恢复缓存信息

## 🎨 UI 设计

### 缓存状态栏

**位置：** 右侧面板顶部，标题下方

**样式：**
- 背景：紫色渐变 (#667eea → #764ba2)
- 高度：自适应
- 动画：从上滑入（0.3s）

**内容：**
- 左侧：📌 图标 + "缓存的思维导图" + 时间
- 右侧：重新生成按钮 + 清空按钮

**按钮样式：**
- 半透明白色背景
- 毛玻璃效果（backdrop-filter）
- Hover 效果：提升 + 阴影
- 重新生成：绿色高亮
- 清空：红色高亮

## 📋 使用场景

### 场景 1：临时关闭查看原文

```
用户操作：
1. 生成思维导图
2. 点击 ✕ 关闭插件
3. 查看原网页内容
4. 重新打开插件

结果：
✅ 思维导图仍然显示
✅ 顶部显示缓存状态栏
✅ 显示"生成于 2分钟前"
```

### 场景 2：切换到不同页面

```
用户操作：
1. 在页面 A 生成思维导图
2. 关闭插件
3. 导航到页面 B
4. 打开插件

结果：
✅ 自动清空页面 A 的思维导图
✅ 显示初始状态
✅ 等待用户生成新的思维导图
```

### 场景 3：页面刷新

```
用户操作：
1. 生成思维导图
2. 按 F5 刷新页面
3. 重新打开插件

结果：
✅ 自动清空（URL 可能有参数变化）
✅ 显示初始状态
```

### 场景 4：长时间后重新打开

```
用户操作：
1. 生成思维导图
2. 关闭插件
3. 35 分钟后重新打开

结果：
✅ 自动清空（超过 30 分钟）
✅ 显示初始状态
```

### 场景 5：想要重新生成

```
用户操作：
1. 打开插件，看到缓存的思维导图
2. 点击 "🔄 重新生成" 按钮

结果：
✅ 清空旧的思维导图
✅ 重新抓取页面内容
✅ 生成新的思维导图
```

## 🧪 测试步骤

### 测试 1：基本缓存功能

1. **打开任意论文网页**
2. **打开插件，生成思维导图**
3. **关闭插件**
4. **重新打开插件**
5. **验证：**
   - ✅ 思维导图仍然显示
   - ✅ 顶部显示紫色状态栏
   - ✅ 显示"缓存的思维导图"和时间

### 测试 2：页面切换自动清空

1. **在页面 A 生成思维导图**
2. **关闭插件**
3. **点击链接导航到页面 B**
4. **打开插件**
5. **验证：**
   - ✅ 思维导图已清空
   - ✅ 显示初始状态
   - ✅ 无缓存状态栏

### 测试 3：重新生成功能

1. **打开插件（有缓存的思维导图）**
2. **点击 "🔄 重新生成" 按钮**
3. **验证：**
   - ✅ 开始重新生成
   - ✅ 显示"生成中..."状态
   - ✅ 生成完成后无缓存状态栏

### 测试 4：清空缓存功能

1. **打开插件（有缓存的思维导图）**
2. **点击 "🗑️ 清空" 按钮**
3. **验证：**
   - ✅ 思维导图被清空
   - ✅ 显示初始状态
   - ✅ 显示"缓存已清空"提示

### 测试 5：时间显示更新

1. **生成思维导图**
2. **关闭插件，等待 2 分钟**
3. **重新打开插件**
4. **验证：**
   - ✅ 显示"生成于 2分钟前"
5. **等待 30 秒**
6. **验证：**
   - ✅ 时间自动更新为"生成于 3分钟前"

## 📊 改进统计

| 功能 | 实现前 | 实现后 |
|------|--------|--------|
| 缓存策略 | 总是保留 | 智能保留 |
| 用户提示 | 无 | 清晰的状态栏 |
| 手动控制 | 只能清空 | 重新生成 + 清空 |
| 时间提示 | 无 | 动态更新 |
| 自动清理 | 无 | 智能检测 |

## 🎯 用户体验提升

1. **清晰度：** 用户明确知道当前显示的是缓存还是新生成的
2. **便利性：** 同一页面快速切换，无需重新生成
3. **准确性：** 自动清空过期或不匹配的内容
4. **控制力：** 用户可以手动重新生成或清空

## 🔧 配置选项

### 修改缓存超时时间

在构造函数中修改：

```javascript
this.cacheTimeout = 30 * 60 * 1000; // 30分钟

// 可以改为：
this.cacheTimeout = 60 * 60 * 1000; // 60分钟
this.cacheTimeout = 10 * 60 * 1000; // 10分钟
```

### 修改时间更新频率

在 `_startCacheTimeUpdater()` 方法中修改：

```javascript
}, 30000); // 30秒

// 可以改为：
}, 60000); // 60秒
}, 10000); // 10秒
```

## 📝 代码文件

### 修改的文件

1. **`extension/content.js`**
   - 添加了 10+ 个新方法
   - 修改了 4 个现有方法
   - 新增约 150 行代码

2. **`extension/content.css`**
   - 添加了缓存状态栏样式
   - 新增约 100 行 CSS

### 新增的 HTML

在右侧面板中添加了缓存状态栏：

```html
<div id="splitCacheStatusBar" class="cache-status-bar" style="display: none;">
    <div class="cache-status-content">
        <span class="cache-icon">📌</span>
        <span class="cache-text">缓存的思维导图</span>
        <span class="cache-time" id="splitCacheTime">生成于 5分钟前</span>
    </div>
    <div class="cache-actions">
        <button id="splitRegenerateBtn">🔄 重新生成</button>
        <button id="splitClearCacheBtn">🗑️ 清空</button>
    </div>
</div>
```

## 🐛 调试信息

启用后，控制台会输出详细日志：

```
🚀 开始显示分屏模式...
✅ 页面未变化，保留缓存的思维导图
📌 检测到缓存的思维导图，显示状态栏
✅ 缓存状态栏已显示
```

或者：

```
🚀 开始显示分屏模式...
🗑️ 检测到URL变化，清空缓存的思维导图
✅ 缓存已清空
```

## 🚀 部署步骤

1. **重新加载扩展**
   ```
   chrome://extensions/ → 找到扩展 → 点击刷新 🔄
   ```

2. **刷新测试页面**
   ```
   按 F5 刷新当前网页
   ```

3. **开始测试**
   - 按照上面的测试步骤验证功能

## 💡 后续优化建议

### 1. 添加设置面板

让用户自定义：
- 缓存超时时间
- 是否启用智能缓存
- 清空策略（总是/智能/从不）

### 2. 多页面缓存

支持缓存多个页面的思维导图：
- 使用 URL 作为 key
- 限制最多缓存 5 个页面
- LRU 策略清理旧缓存

### 3. 缓存同步

使用 Chrome Storage API：
- 跨标签页同步
- 持久化存储
- 更可靠的缓存管理

### 4. 更丰富的提示

状态栏显示更多信息：
- 思维导图节点数量
- 使用的 AI 模型
- 生成耗时

### 5. 手势操作

添加快捷操作：
- 双击状态栏：重新生成
- 右键状态栏：显示菜单

## 📈 预期效果

### 用户反馈

- 😊 "很方便，不用每次都重新生成"
- 😊 "清楚地知道这是缓存的还是新的"
- 😊 "切换页面自动清空，很智能"
- 😊 "重新生成按钮很实用"

### 使用数据

预计：
- 重复生成减少 60%
- API 调用成本降低 60%
- 用户满意度提升 40%

## 🎨 视觉效果

### 缓存状态栏

```
┌──────────────────────────────────────────────────────┐
│  📌 缓存的思维导图  生成于 5分钟前                       │
│                           [🔄 重新生成] [🗑️ 清空]       │
└──────────────────────────────────────────────────────┘
```

**颜色方案：**
- 背景：紫色渐变 (#667eea → #764ba2)
- 文字：白色
- 按钮：半透明白色，Hover 时高亮

**动画效果：**
- 出现：从上滑入 (0.3s)
- 图标：轻微脉动 (2s 循环)
- 按钮：Hover 提升 + 阴影

## 📚 相关文档

- `QUICK_START.md` - 快速启动指南
- `REFACTORING_SUMMARY.md` - 代码重构总结
- `PROVIDER_FIX.md` - Provider 映射修复
- `METHOD_REWRITE_SUMMARY.md` - 方法重写总结

---

**实现完成时间：** 2025-11-27
**状态：** ✅ 已完成，准备测试
**语法检查：** ✅ 通过











